function result = f_johnson_M(mu,sd,skew,kurt)
% - use moments to estimate parameters of a Johnson distribution
%
% USAGE: result = f_johnson_M(mu,sd,skew,kurt)
%
% mu   = mean
% sd   = standard deviation
% skew = skewness
% kurt = kurtosis
%
% result = structure of results with the following fields:
%  .coef = parameters as: coef = [gamma delta xi lambda];
%  .type = type of Johnson distribution as: SL, SU, SB, SN, or ST
%
% SEE ALSO: f_johnson_fit, f_johnson_Q

% -----Notes:-----
% This function implements Hill et al.'s (1976) algorithm for estimating the
% parameters of a Johnson curve using moments. It is based on their original
% FORTRAN souce code (AS-99), which was obtained from
% http://lib.stat.cmu.edu/apstat/99. For SN (Normal) curves they arbitrarily set
% lambda to 0, but the present function sets lambda = 1. This produces the
% correct identity transform needed by their companion algorithm (AS-100) and
% the 'f_johnson_y2z' & 'f_johnson_z2y' functions in this toolbox. The C code
% mentioned in Simonato (2011) does this as well, but is not mentioned in the
% documentation.
%
% The coefficients of a Johnson curve consist of shape (gamma & delta),
% location (xi), and scale (lambda) parameters and use the following transforms:
%  SL: Lognormal distribution = exponential transform
%  SU: Unbounded distribution = hyperbolic sine transform
%  SB: Bounded distribution   = logistic transforma
% 
% Hill et al.'s (1976) algorithm adds support for two additional families as:
%  SN: Normal distribution = identity transform
%  ST: SB curves on the B2 = B1+1 boundary (T refers to "two-ordinate")
%
% SL curves are bounded on one end (e.g., Gamma distribution), while SB curves
% are bounded on both ends (e.g., Beta distribution). SU curves are unbounded
% (e.g., the Normal and t distributions).
% 
% Note that the SN and ST families were added to the Johnson system by Hill et
% al. (1976), the former being the normal distribution. The parameters returned
% by fitting an ST curve are not used to transform the normal curve like they
% are in the other families. For ST curves, xi and lambda represent the
% ordinates on the skewness-kurtosis plane, delta is the proportion of values at
% lambda, and gamma is set to 0.

% -----References:-----
% Hill, I. D. 1976. Algorithm AS 100: Normal-Johnson and Johnson-Normal
%  Transformations. Journal of the Royal Statistical Society. Series C (Applied
%  Statistics) 25(2): 190-192.
% Hill, I. D., R. Hill, and R. L. Holder, 1976. Algorithm AS 99: Fitting Johnson
%  curves by moments. Journal of the Royal Statistical Society. Series C
%  (Applied Statistics) 25(2): 180-189.
% Johnson, N. L. 1949. Systems of frequency curves generated by methods of
%  translation. Biometrika 36: 149-176.
% Simonato, J. G. 2011. The performance of Johnson distributions for value at
%  risk and expected shortfall computation. Journal of Derivatives 19:7-24.

% -----Author:-----
% by David L. Jones, Mar-2014
%
% This file is part of the 'JOHNSON CURVE TOOLBOX FOR MATLAB'
% and is released under the BSD 2-clause license.

% -----Set defaults & check input:-----
% Check for scalars:
if (sum([isscalar(mu) isscalar(sd) isscalar(skew) isscalar(kurt)])<4)
   error('All inputs must be scalars!');
end

% Check for negative SD:
if (sd<0), error('Cannot have a negative SD!'); end
% -------------------------------------

% Call subfunction ported from Hill et al.'s (1976) FORTRAN code:
[gamma,delta,lambda,xi,itype,ifault] = sub_jnsn(mu,sd,skew,kurt);

% Rearrange coefficients for consistent output:
coef = [gamma delta xi lambda];

% Recode Johnson curve types:
switch itype
   case 1
      type = 'SL';
   case 2
      type = 'SU';
   case 3
      type = 'SB';
   case 4
      type = 'SN';
   case 5
      type = 'ST';
   otherwise
      error('Unknown ITYPE!');
end

% Record fault state:
switch ifault
   case 0
      msg = []; % normal completion
   case 1
      msg = 'Negative SD';
   case 2
      msg = '(b2 < b1+two)';
   otherwise
      msg = 'SB failure, SL or ST used instead';
end

% Wrap results up into a structure:
result.coef = coef;
result.type = type;
if ~isempty(msg), result.msg  = msg; end

end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                               SUBFUNCTION:                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [gamma,delta,xlam,xi,itype,ifault] = sub_jnsn(xbar,sd,rb1,bb2)
% - finds type and parameters of a Johnson curve with given first four moments

% Define constants:
tol = 0.01; zero = 0.0; quart = 0.25; half = 0.5; one = 1.0; two = 2.0;
three = 3.0; four  = 4.0;

% Check for negative SD:
if (sd < zero),
   itype  = NaN; gamma = NaN; delta = NaN; xlam = NaN; xi = NaN; ifault = 1;
   return
else
   ifault = 0;
   xi     = zero;
   xlam   = zero;
   gamma  = zero;
   delta  = zero;
end

if (sd > zero)
   b1    = rb1*rb1;
   b2    = bb2;
   fault = 0;
   % Test whether Lognormal (or Normal) requested:
   if (b2 >= zero)
      % Test for position relative to boundary line:
      if (b2 > b1+tol+one)
         if ((abs(rb1) <= tol) && (abs(b2-three) <= tol))
            n_GOTO('SN');
            return
         else
            stopWhile = 0; % proceed to WHILE loop
            skip      = 1; % skip first line of WHILE loop:
         end
      else
         if (b2 >= b1+one), n_GOTO('ST'); return; end
         itype  = 5; % no 'itype' was included here in original FORTRAN 
         ifault = 2;
         return
      end
   else
      stopWhile = 0; % proceed to WHILE loop
      skip      = 0; % don't skip 1st line of WHILE loop
   end
else
   itype = 5;
   xi    = xbar;
   return
end


while (stopWhile==0)
   % -----Skip this block on 1st run:-----
   if (skip==1)
      skip = 0; % don't skip anymore
   else
      if ~(abs(rb1) > tol)
         n_GOTO('SN');
         return
      end
   end
   % -------------------------------------
   % Test for position relative to Lognormal line:
   x = half*b1 + one;
   y = abs(rb1)*sqrt(quart*b1+one);
   u = (x+y)^(one/three);
   w = u + one/u - one;
   u = w*w*(three+w*(two+w)) - three;
   if ((b2 < zero) || (fault)), b2 = u; end
   x = u - b2;
   if (abs(x) <= tol)
      % Lognormal (SL) distribution:
      itype = 1;
      xlam  = sub_sign(one,rb1);
      u     = xlam*xbar;
      x     = one/sqrt(log(w));
      delta = x;
      y     = half*x*log(w*(w-one)/(sd*sd));
      gamma = y;
      xi    = xlam*(u-exp((half/x-y)/x));
      return
      % SB or SU distribution:
   elseif (x > zero)
      itype = 3;
      [gamma,delta,xlam,xi,fault] = sub_sbfit(xbar,sd,rb1,b2);
      if (fault==0), return; end
      % Failure - try to fit approximate result:
      ifault = 3;
      if (b2 <= b1+two)
         n_GOTO('ST');
         return
      else
         skip = 0; % don't skip 1st line of WHILE loop
         continue  % next iteration of WHILE loop
      end
   else
      itype = 2;
      [gamma,delta,xlam,xi] = sub_sufit(xbar,sd,rb1,b2);
      stopWhile=1;
   end
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              NESTED FUNCTION:                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   function n_GOTO(where)
      % - nested function of sub_jnsn to emulate 'GOTO' statements from FORTRAN
      switch where
         case 'SN';
            % SN (Normal) distribution:
            itype = 4;
            delta = one/sd;
            gamma = -xbar/sd;
            xlam  = one; % after Simonato (2011)
         case 'ST';
            % ST distribution:
            itype = 5;
            y     = half + half*sqrt(one-four/(b1+four));
            if (rb1 > zero), y = one - y; end
            x     = sd/sqrt(y*(one-y));
            xi    = xbar - y*x;
            xlam  = xi + x;
            delta = y;
         otherwise
            error('Unknown parameter for WHERE!')
      end
   end
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                               SUBFUNCTION:                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function A = sub_sign(A,B)
% - port of SIGN statement from FORTRAN
%
% If B\ge 0 then the result is ABS(A), else it is -ABS(A).
A      = abs(A);
A(B<0) = A(B<0) * -1;
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                               SUBFUNCTION:                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [gamma,delta,xlam,xi] = sub_sufit(xbar,sd,rb1,b2)
% - finds parameters of Johnson SU curve with given first four moments

% Define constants:
tol = 0.01; zero = 0.0; one = 1.0; two = 2.0; three = 3.0; four = 4.0; six = 6.0;
seven = 7.0; eight = 8.0; nine = 9.0; ten = 10.0; sixten = 16.0; half = 0.5;
one5 = 1.5; two8 = 2.8; b1 = rb1 * rb1; b3 = b2 - three;

% w is first estimate of exp(delta^(-2)):
w = sqrt(two*b2-two8*b1-two);
w = sqrt(w-one);

% Initialize:
stopWhile = 0;

if (abs(rb1)>tol)
   while (stopWhile==0) % Johnson iteration:
      w1  = w + one;
      wm1 = w - one;
      z   = w1*b3;
      v   = w*(six+w*(three+w));
      a   = eight*(wm1*(three+w*(seven+v))-z);
      b   = sixten*(wm1*(six+v)-b3);
      y   = (sqrt(a*a-two*b*(wm1*(three+w*(nine+w*(ten+v)))-two*w1*z))-a)/b;
      z   = y*wm1*(four*(w+two)*y+three*w1*w1)^2/(two*(two*y+w1)^3);
      v   = w*w;
      w   = sqrt(one-two*(one5-b2+(b1*(b2-one5-v*(one+half*v)))/z));
      w   = sqrt(w-one);
      if (abs(b1-z) <= tol)
         y = y/w;
         y = log(sqrt(y)+sqrt(y+one));
         if (rb1 > zero), y = -y; end
         break % terminate WHILE loop
      else
         % continue next iteration of WHILE loop
      end
   end
else
   % Symmetrical case - results are known
   y = zero;
end
x     = sqrt(one/log(w));
delta = x;
gamma = y*x;
y     = exp(y);
z     = y*y;
x     = sd/sqrt(half*(w-one)*(half*w*(z+one/z)+one));
xlam  = x;
xi    = (half*sqrt(w)*(y-one/y))*x + xbar;
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                               SUBFUNCTION:                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [gamma,delta,xlam,xi,fault] = sub_sbfit(xbar,sigma,rtb1,b2)
% - finds parameters of Johnson SB curve with given first four moments

% Preallocate:
deriv = nan(4,1); dd = nan(4,1);

% Define constants:
tt = 1.0e-4; tol = 0.01; limit = 50; zero = 0.0; one = 1.0; two = 2.0;
three = 3.0; four = 4.0; six = 6.0; half = 0.5; quart = 0.25; one5 = 1.5;
a1 = 0.0124; a2 = 0.0623; a3 = 0.4043; a4 = 0.408; a5 = 0.479; a6 = 0.485;
a7 = 0.5291; a8 = 0.5955; a9 = 0.626; a10 = 0.64; a11 = 0.7077; a12 = 0.7466;
a13 = 0.8; a14 = 0.9281; a15 = 1.0614; a16 = 1.25; a17 = 1.7973; a18 = 1.8;
a19 = 2.163; a20 = 2.5; a21 = 8.5245; a22 = 11.346; rb1 = abs(rtb1);
b1 = rb1 * rb1; neg = (rtb1 < zero);

% Get d as first estimate of delta:
e = b1 + one;
x = half*b1 + one;
y = abs(rb1)*sqrt(quart*b1+one);
u = (x+y)^(one/three);
w = u + one/u - one;
f = w*w*(three+w*(two+w)) - three;
e = (b2-e)/(f-e);
if (abs(rb1)>tol)
   d = one/sqrt(log(w));
   if (d < a10)
      f = a16*d;
   else
      f = two - a21/(d*(d*(d-a19)+a22));
   end
else
   f = two;
end
f = e*f + one;
if (f < a18)
   d = a13*(f-one);
else
   d = (a9*f-a4)*(three-f)^(-a5);
end

% Get g as first estimate of gamma:
g = zero;
if (b1 >= tt)
   if (d > one)
      if (d <= a20)
         u = a2;
         y = a3;
      else
         u = a1;
         y = a7;
      end
      g = b1^(u*d+y)*(a14+d*(a15*d-a11));
   else
      g = (a12*d^a17+a8)*b1^a6;
   end
end

% -----Main iteration starts here:-----
stopWhile = 0; % initialize
m    = 0;
while (stopWhile==0)
   m     = m + 1;
   fault = (m > limit);
   if (fault), n_fault; return; end
   
   % Get first six moments for latest g and d values:
   [hmu,fault] = sub_mom(g,d);
   if (fault), n_fault; return; end
   s     = hmu(1)*hmu(1);
   h2    = hmu(2) - s;
   fault = (h2 <= zero);
   if (fault), n_fault; return; end
   t    = sqrt(h2);
   h2a  = t*h2;
   h2b  = h2*h2;
   h3   = hmu(3) - hmu(1)*(three*hmu(2)-two*s);
   rbet = h3/h2a;
   h4   = hmu(4) - hmu(1)*(four*hmu(3)-hmu(1)*(six*hmu(2)-three*s));
   bet2 = h4/h2b;
   w    = g*d;
   u    = d*d;
   
   % Get derivatives:
   for j = 1:2
      for k = 1:4
         t = k;
         if (j==1)
            s = hmu(k+1) - hmu(k);
         else
            s = ((w-t)*(hmu(k)-hmu(k+1))+(t+one)*(hmu(k+1)-hmu(k+2)))/u;
         end
         dd(k) = t*s/d;
      end
      t          = two*hmu(1)*dd(1);
      s          = hmu(1)*dd(2);
      y          = dd(2) - t;
      deriv(j)   = (dd(3)-three*(s+hmu(2)*dd(1)-t*hmu(1))-one5*h3*y/h2)/h2a;
      deriv(j+2) = (dd(4)-four*(dd(3)*hmu(1)+dd(1)*hmu(3))+six*(hmu(2)*t+...
         hmu(1)*(s-t*hmu(1)))-two*h4*y/h2)/h2b;
   end
   t = one/(deriv(1)*deriv(4)-deriv(2)*deriv(3));
   u = (deriv(4)*(rbet-rb1)-deriv(2)*(bet2-b2))*t;
   y = (deriv(1)*(bet2-b2)-deriv(3)*(rbet-rb1))*t;
   
   % Form new estimates of g and d:
   g = g - u;
   if ((b1 == zero) || (g < zero)), g = zero; end
   d = d - y;
   
   % Assess WHILE loop:
   if ((abs(u) <= tt) && (abs(y) <= tt))
      delta = d;
      xlam  = sigma/sqrt(h2);
      if (neg)
         gamma  = -g;
         hmu(1) = one - hmu(1);
      else
         gamma  = g;
      end
      xi = xbar - xlam*hmu(1);
      break % terminate WHILE loop
   end
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              NESTED FUNCTION:                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   function n_fault
      % - assigns something to output arguments when fault=1
      gamma = 0;
      delta = 0;
      xlam  = 0;
      xi    = 0;
   end
end



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                               SUBFUNCTION:                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [a,fault] = sub_mom(g,d)
% - evaluates 1st six moments of a johnson SB distribution, using Goodwin method

% -----Notes:-----
% rttwo : sqrt(2.0)
% rrtpi : reciprocal of sqrt(pi)
% expa  : a value such that exp(expa) does not quite cause overflow
% expb  : a value such that 1.0 + exp(-expb) may be taken to be 1.0

% Define constants:
zz = 1.0e-5; vv = 1.0e-8; limit = 500; rttwo = 1.414213562; rrtpi = 0.5641895835;
expa = 80.0; expb = 23.7; zero = 0.0; quart = 0.25; half = 0.5; p75 = 0.75;
one = 1.0; two = 2.0; three = 3.0; w = g/d;

% Preallocate or initialize:
a     = nan(6,1);
b     = nan(6,1);
fault = 0;
c     = zeros(6,1);

% Trial value of h:
if (w > expa), fault = 1; return; end
e = exp(w) + one;
r = rttwo/d;
h = p75;
if (d < three), h = quart*d; end
k = 1;

% -----OUTER WHILE loop:-----
skip     = 1; % skip 1st block of outer WHILE loop on 1st run
stop_out = 0; % initiialize
while (stop_out==0)
   % -----Skip this block on 1st run:-----
   if (skip==1)
      skip = 0; % don't skip anymore:
   else
      k = k + 1;
      if ( k > limit ), fault = 1; return; end;
      for i = 1:6
         c(i) = a(i);
      end
      %  No convergence yet - try smaller h:
      h = half*h;
   end
   % -------------------------------------
   t = w;
   u = t;
   y = h*h;
   x = two*y;
   a(1) = one/e;
   for i = 2:6
      a(i) = a(i-1)/e;
   end
   v = y;
   f = r*h;
   m = 0;
   % -----INNER WHILE loop evaluates infinite series:-----
   stop_inn = 0;
   while (stop_inn==0)
      m = m + 1;
      if (m > limit), break; end % terminate INNER WHILE loop
      for i = 1:6
         b(i) = a(i);
      end
      u = u - f;
      z = one;
      if (u > -expb), z = exp(u) + z; end
      t = t + f;
      l = (t > expb);
      if (l==0), s = exp(t) + one; end
      p = exp(-v);
      q = p;
      for i = 1:6
         aa = a(i);
         p  = p/z;
         ab = aa;
         aa = aa + p;
         if (aa == ab), break; end % terminate this FOR loop
         if (l==0)
            q  = q/s;
            ab = aa;
            aa = aa + q;
            l = (aa==ab);
         end
         a(i) = aa;
      end
      y = y + x;
      v = v + y;
      for i = 1:6
         if (a(i)==zero), fault = 1; return; end
         if (abs((a(i)-b(i))/a(i)) > vv)
            cont_inn = 1; % continue next iteration of INNER WHILE loop
            break;        % terminate this FOR loop
         else
            cont_inn = 0; % don't continue
         end
      end
      if (cont_inn==1), continue; end % skip to start of INNER WHILE loop
      v = rrtpi*h;
      for i = 1:6
         a(i) = v*a(i);
      end
      for i = 1:6
         if (a(i) == zero), fault = 1; return; end
         if (abs((a(i)-c(i))/a(i)) > zz)
            break_out = 1; % signal OUTER WHILE loop should be terminated
            break;         % terminate this FOR loop
         else
            break_out = 0; % don't terminate OUTER WHILE loop
         end
      end
      if (break_out==1); break; end % terminate INNER WHILE loop
   end
   % -----------------------------------------------------
   if (break_out==1); break; end % terminate OUTER WHILE loop
end
% ---------------------------
end
