<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of nt_cluster_jd</title>
  <meta name="keywords" content="nt_cluster_jd">
  <meta name="description" content="[IDX,todss,SCORE]=nt_cluster_jd(x,dsr,smooth,flags,init,verbose) - cluster with joint diagonalization">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">NoiseTools</a> &gt; nt_cluster_jd.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for NoiseTools&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>nt_cluster_jd
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>[IDX,todss,SCORE]=nt_cluster_jd(x,dsr,smooth,flags,init,verbose) - cluster with joint diagonalization</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [IDX,TODSS,SCORE]=nt_cluster_jd(x,dsr,smooth,flags,init,verbose) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment">[IDX,todss,SCORE]=nt_cluster_jd(x,dsr,smooth,flags,init,verbose) - cluster with joint diagonalization

  IDX: cluster ownership (IDX{1}: low amp, IDX{2{: high amp)
  TODSS: DSS matrix (1st column --&gt; discriminating component)
  SCORE: score (smaller means better contrast)

  x: data (time*channels)
  dsr: downsample ratio for cross product series
  smooth: further smooth cross-product series
  flags: 'norm', 'norm2': give each dsr-sized slice the same weight
  init: provide initial clustering
  verbose: display &amp; plot (default=no)

 See nt_bias_cluster, nt_cluster1D</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="nt_cluster1D.html" class="code" title="function [C,A,score]=nt_cluster1D_b(x);">nt_cluster1D</a>	[C,A,score]=nt_cluster1D_b(x) - cluster 1D data into 2 clusters</li><li><a href="nt_cov.html" class="code" title="function [c,tw]=nt_cov(x,shifts,w);">nt_cov</a>	[c,tw]=nt_cov(x,shifts,w) - time shift covariance</li><li><a href="nt_dss0.html" class="code" title="function [todss,pwr0,pwr1]=nt_dss0(c0,c1,keep1,keep2)">nt_dss0</a>	[todss,pwr1,pwr2]=nt_dss0(c0,c1,keep1,keep2) - dss from covariance</li><li><a href="nt_linecolors.html" class="code" title="function nt_colorlines(h,permutation)">nt_linecolors</a>	nt_colorlines(h,permutation) - apply different colors to lines of plot</li><li><a href="nt_mmat.html" class="code" title="function y=nt_mmat(x,m)">nt_mmat</a>	y=nt_mmat(x,m) -  matrix multiplication (with convolution)</li><li><a href="nt_normcol.html" class="code" title="function [y,norm]=nt_normcol(x,w)">nt_normcol</a>	[y,norm]=nt_normcol(x,w) - normalize each column so its weighted msq is 1</li><li><a href="nt_normrow.html" class="code" title="function x=nt_normrow(x)">nt_normrow</a>	y=nt_normcol(x) - normalize each row so its msq is 1</li><li><a href="nt_sgram.html" class="code" title="function [s,f,t]=nt_sgram(x,window,noverlap,nfft,sr,flags)">nt_sgram</a>	[s,f,t]=nt_sgram(x,window,noverlap,nfft,sr,flags) - spectrogram</li><li><a href="nt_smooth.html" class="code" title="function x=nt_smooth(x,T,nIterations,nodelayflag)">nt_smooth</a>	y=nt_smooth(x,T,nIterations,nodelayflag) - smooth by convolution with square window</li><li><a href="nt_spect_plot.html" class="code" title="function varargout=nt_spect_plot(x,varargin)">nt_spect_plot</a>	nt_spect_plot - plot power spectrum</li><li><a href="nt_xprod.html" class="code" title="function [y,ind]=nt_xprod(x,flag,dsratio,normrow_flag)">nt_xprod</a>	[y,ind]=nt_xprod(x,flag,dsratio,normrow_flag) - form all crossproducts</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="nt_enforce_stationarity.html" class="code" title="function x=nt_enforce_stationarity(x,DSR,thresh);">nt_enforce_stationarity</a>	y=nt_enforce_stationarity(x,DSR,thresh) - locally project out non-stationary components</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function y=norm2(x,n,ind)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [IDX,TODSS,SCORE]=nt_cluster_jd(x,dsr,smooth,flags,init,verbose)</a>
0002 <span class="comment">%[IDX,todss,SCORE]=nt_cluster_jd(x,dsr,smooth,flags,init,verbose) - cluster with joint diagonalization</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%  IDX: cluster ownership (IDX{1}: low amp, IDX{2{: high amp)</span>
0005 <span class="comment">%  TODSS: DSS matrix (1st column --&gt; discriminating component)</span>
0006 <span class="comment">%  SCORE: score (smaller means better contrast)</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%  x: data (time*channels)</span>
0009 <span class="comment">%  dsr: downsample ratio for cross product series</span>
0010 <span class="comment">%  smooth: further smooth cross-product series</span>
0011 <span class="comment">%  flags: 'norm', 'norm2': give each dsr-sized slice the same weight</span>
0012 <span class="comment">%  init: provide initial clustering</span>
0013 <span class="comment">%  verbose: display &amp; plot (default=no)</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% See nt_bias_cluster, nt_cluster1D</span>
0016 
0017 
0018 <span class="keyword">if</span> nargin&lt;2; error(<span class="string">'!'</span>); <span class="keyword">end</span>
0019 <span class="keyword">if</span> nargin&lt;3 ||isempty(smooth); smooth=1; <span class="keyword">end</span>
0020 <span class="keyword">if</span> nargin&lt;4 ||isempty(flags); flags=[]; <span class="keyword">end</span>
0021 <span class="keyword">if</span> nargin&lt;5; init=[]; <span class="keyword">end</span>
0022 <span class="keyword">if</span> nargin&lt;6||isempty(verbose); verbose=0; <span class="keyword">end</span>
0023 
0024 <span class="keyword">if</span> ~nargout; disp(<span class="string">'entering nt_cluster_jd...'</span>); <span class="keyword">end</span>
0025 
0026 <span class="keyword">if</span> ndims(x)&gt;2 || size(x,2) ==1;
0027     error(<span class="string">'should be 2D matrix'</span>);
0028 <span class="keyword">end</span>
0029 
0030 
0031 <span class="comment">%{</span>
0032  Calculate the time series of cross products (terms of the covariance matrix).
0033  This time series has coarser temporal resolution than x by a factor dsr.
0034 <span class="comment">%}</span>
0035 [xx,ind]=<a href="nt_xprod.html" class="code" title="function [y,ind]=nt_xprod(x,flag,dsratio,normrow_flag)">nt_xprod</a>(x,<span class="string">'lower'</span>,dsr);  
0036 
0037 <span class="comment">% figure(2); clf;</span>
0038 <span class="comment">% subplot 211;</span>
0039 <span class="comment">% plot(xx)</span>
0040 
0041 <span class="comment">% option: give each slice the same weight (counters amplitude variations)</span>
0042 <span class="keyword">if</span> find(strcmp(flags,<span class="string">'norm'</span>))
0043     xx=<a href="nt_normrow.html" class="code" title="function x=nt_normrow(x)">nt_normrow</a>(xx);
0044 <span class="keyword">end</span>
0045 <span class="keyword">if</span> find(strcmp(flags,<span class="string">'norm2'</span>))
0046     xx=<a href="#_sub1" class="code" title="subfunction y=norm2(x,n,ind)">norm2</a>(xx,size(x,2),ind);
0047 <span class="keyword">end</span>
0048 
0049 <span class="comment">% subplot 212;</span>
0050 <span class="comment">% plot(xx);</span>
0051 <span class="comment">% pause;</span>
0052 
0053 smooth
0054 size(xx)
0055 xx=<a href="nt_smooth.html" class="code" title="function x=nt_smooth(x,T,nIterations,nodelayflag)">nt_smooth</a>(xx,smooth,[],1);
0056 
0057 <span class="comment">%{</span>
0058 Cluster each column the time series of cross products, 
0059 choose the column with best score (reduction in energy), 
0060 and use it's cluster index to initialize the first JD analysis.
0061 <span class="comment">%}</span>
0062 <span class="keyword">if</span> isempty(init)
0063     [C,A,score]=<a href="nt_cluster1D.html" class="code" title="function [C,A,score]=nt_cluster1D_b(x);">nt_cluster1D</a>(xx);
0064     [~,idx]=min(score); <span class="comment">% select column with best score (tightest clusters)</span>
0065     A=A(:,idx); 
0066         
0067     <span class="comment">% upsample the cluster ownership index so we can apply it to x</span>
0068     A=repmat(A',[dsr,1]);
0069     A=A(:);
0070     A(end:size(x,1))=A(end);
0071     IDX{1}=find(A==0);
0072 <span class="keyword">else</span>
0073     IDX{1}=init;
0074 <span class="keyword">end</span>
0075 
0076 <span class="comment">% initial DSS to contrast clusters</span>
0077 c0=<a href="nt_cov.html" class="code" title="function [c,tw]=nt_cov(x,shifts,w);">nt_cov</a>(x);
0078 c1=<a href="nt_cov.html" class="code" title="function [c,tw]=nt_cov(x,shifts,w);">nt_cov</a>(x(IDX{1},:));
0079 [todss,pwr0,pwr1]=<a href="nt_dss0.html" class="code" title="function [todss,pwr0,pwr1]=nt_dss0(c0,c1,keep1,keep2)">nt_dss0</a>(c0,c1);
0080 todss2=todss(:,[1 end]); <span class="comment">% keep only first and last components</span>
0081 z=<a href="nt_mmat.html" class="code" title="function y=nt_mmat(x,m)">nt_mmat</a>(x,todss2);
0082 
0083 PLOT_FIG2=0;
0084 <span class="keyword">if</span> PLOT_FIG2
0085     figure(2);  clf; set(gcf, <span class="string">'name'</span>,<span class="string">'in nt_cluster_jd'</span>);
0086     A=zeros(size(x,1),1); A(IDX{1})=1;
0087     subplot 411; plot(x); title(<span class="string">'data'</span>);
0088     subplot 412; plot(A,<span class="string">'.-'</span>); title(<span class="string">'initial cluster map'</span>);
0089     subplot 413; plot(z(:,1)); title(<span class="string">'initial DSS1'</span>);
0090     subplot 414; plot(z(:,2)); title(<span class="string">'initial DSS2'</span>);
0091     drawnow; pause;
0092 <span class="keyword">end</span>
0093 
0094 <span class="comment">% iterate until stable</span>
0095 old_IDX=IDX{1};
0096 <span class="keyword">for</span> k=1:10
0097 
0098     [zz,ind]=<a href="nt_xprod.html" class="code" title="function [y,ind]=nt_xprod(x,flag,dsratio,normrow_flag)">nt_xprod</a>(z,[],dsr);
0099     zz=zz(:,1:2);       <span class="comment">% keep only the squares</span>
0100     zz=log2(zz+eps);    <span class="comment">% log to make it sensitive to power ratio</span>
0101     [C,A]=<a href="nt_cluster1D.html" class="code" title="function [C,A,score]=nt_cluster1D_b(x);">nt_cluster1D</a>(zz);
0102     [~,idx]= max(diff(C));    <span class="comment">% the best component is the one with greatest ratio</span>
0103     A=A(:,idx);
0104     
0105     <span class="comment">%plot(nt_smooth(A,smooth, [],1));</span>
0106     
0107     A=double(<a href="nt_smooth.html" class="code" title="function x=nt_smooth(x,T,nIterations,nodelayflag)">nt_smooth</a>(A,smooth, [],1)&gt;=1/smooth); <span class="comment">% extend ownership to include effect of smoothing</span>
0108 
0109     <span class="comment">% upsample the cluster ownership index so we can apply it to x</span>
0110     A=repmat(A',[dsr,1]); <span class="comment">% upsample</span>
0111     A=A(:); 
0112     A(end:size(x,1))=A(end);
0113     IDX{1}=find(A==0); <span class="comment">% 0: low values, 1: high values</span>
0114     
0115     
0116     <span class="comment">% DSS to contrast clusters</span>
0117     c0=<a href="nt_cov.html" class="code" title="function [c,tw]=nt_cov(x,shifts,w);">nt_cov</a>(x)/size(x,1);
0118     c1=<a href="nt_cov.html" class="code" title="function [c,tw]=nt_cov(x,shifts,w);">nt_cov</a>(x(IDX{1},:))/size(x(IDX{1},:),1);
0119     [todss,pwr0,pwr1]=<a href="nt_dss0.html" class="code" title="function [todss,pwr0,pwr1]=nt_dss0(c0,c1,keep1,keep2)">nt_dss0</a>(c0,c1);
0120     z=<a href="nt_mmat.html" class="code" title="function y=nt_mmat(x,m)">nt_mmat</a>(x,todss(:,[1 end])); <span class="comment">% keep first and last</span>
0121 
0122     <span class="keyword">if</span> ~nargout||verbose; 
0123         disp([<span class="string">'low amp cluster: '</span>, num2str((100*numel(IDX{1})/size(x,1)), 2), <span class="string">' % of samples, power ratio: '</span> num2str(pwr1(end)/pwr0(end), 3)]); 
0124     <span class="keyword">end</span>
0125 
0126     <span class="keyword">if</span> PLOT_FIG2
0127         figure(2);  
0128         subplot 515; plot(A,<span class="string">'.-'</span>); title(<span class="string">'final cluster map'</span>);
0129     <span class="keyword">end</span>
0130     <span class="keyword">if</span> all(size(old_IDX)==size(IDX{1})) &amp;&amp; all(old_IDX==IDX{1}); <span class="keyword">break</span>; <span class="keyword">end</span>
0131     old_IDX=IDX{1};
0132 <span class="keyword">end</span> 
0133 IDX{2}=setdiff(1:size(x,1), IDX{1});
0134 
0135 <span class="comment">% score</span>
0136 [TODSS,pwr0,pwr1]=<a href="nt_dss0.html" class="code" title="function [todss,pwr0,pwr1]=nt_dss0(c0,c1,keep1,keep2)">nt_dss0</a>(c0,c1);
0137 SCORE=pwr1(end)/pwr0(end);
0138 
0139 nargout
0140 
0141 <span class="keyword">if</span> nargout==0||verbose;
0142     
0143     <span class="comment">% no output, just plot</span>
0144 
0145     z1=<a href="nt_mmat.html" class="code" title="function y=nt_mmat(x,m)">nt_mmat</a>(x,TODSS(:,1));
0146     z2=<a href="nt_mmat.html" class="code" title="function y=nt_mmat(x,m)">nt_mmat</a>(x,TODSS(:,end));
0147 
0148     figure(101); clf ;
0149     subplot 221;
0150     plot(pwr1./pwr0,<span class="string">'.-'</span>); xlabel(<span class="string">'component'</span>); ylabel(<span class="string">'score'</span>); title(<span class="string">'DSS cluster [low amp] vs all'</span>);
0151     subplot 222;
0152     wsize=min(1024,size(z2,1));
0153     <span class="comment">%nt_spect_plot(z1/sqrt(mean(z1(:).^2)),wsize,[],[],1);</span>
0154     hold on
0155     <a href="nt_spect_plot.html" class="code" title="function varargout=nt_spect_plot(x,varargin)">nt_spect_plot</a>(z2/sqrt(mean(z2(:).^2)),wsize,[],[],1);
0156     <a href="nt_spect_plot.html" class="code" title="function varargout=nt_spect_plot(x,varargin)">nt_spect_plot</a>(x/sqrt(mean(x(:).^2)),wsize,[],[],1);
0157     xlim([0 .5]);
0158     <a href="nt_linecolors.html" class="code" title="function nt_colorlines(h,permutation)">nt_linecolors</a>([],[1 3 2]);
0159     legend(<span class="string">'last'</span>,<span class="string">'all'</span>); legend boxoff
0160     hold off
0161 
0162     z=<a href="nt_mmat.html" class="code" title="function y=nt_mmat(x,m)">nt_mmat</a>(x,todss); 
0163     z=<a href="nt_normcol.html" class="code" title="function [y,norm]=nt_normcol(x,w)">nt_normcol</a>(z);
0164     subplot 223; imagescc(<a href="nt_cov.html" class="code" title="function [c,tw]=nt_cov(x,shifts,w);">nt_cov</a>(z(IDX{1},:))); title(<span class="string">'cluster [low amp]'</span>); 
0165     subplot 224; imagescc(<a href="nt_cov.html" class="code" title="function [c,tw]=nt_cov(x,shifts,w);">nt_cov</a>(z)-<a href="nt_cov.html" class="code" title="function [c,tw]=nt_cov(x,shifts,w);">nt_cov</a>(z(IDX{1},:))); title(<span class="string">'cluster [high amp]'</span>);
0166 
0167     
0168     figure(102); clf
0169     <span class="keyword">if</span> 0
0170         subplot 311;
0171         plot(x); hold on
0172         xx=x; xx(IDX{1},:)=nan;
0173         plot(xx,<span class="string">'k'</span>);
0174         axis tight
0175         title(<span class="string">'black: cluster [high amp]'</span>);
0176         subplot 312;
0177         plot(z1); axis tight
0178         title(<span class="string">'first DSS component'</span>);
0179         subplot 313;
0180         plot(z2); axis tight
0181         title(<span class="string">'last DSS component'</span>);
0182     <span class="keyword">else</span>
0183         subplot 311;
0184         plot(x); hold on
0185         xx=x; xx(IDX{1},:)=nan;
0186         plot(xx,<span class="string">'k'</span>);
0187         axis tight
0188         title(<span class="string">'black: cluster [high amp]'</span>);
0189         subplot 312;
0190         plot(z2); axis tight
0191         title(<span class="string">'last DSS component'</span>);
0192         subplot 313;
0193         <a href="nt_sgram.html" class="code" title="function [s,f,t]=nt_sgram(x,window,noverlap,nfft,sr,flags)">nt_sgram</a>(z2,128,1); axis tight
0194         title(<span class="string">'last DSS component'</span>);
0195     <span class="keyword">end</span>
0196     
0197     <span class="keyword">if</span> 1 
0198         figure(105); clf
0199         subplot 211;
0200         <span class="comment">%sr=44100; ERBspect(z1,sr);</span>
0201         <a href="nt_sgram.html" class="code" title="function [s,f,t]=nt_sgram(x,window,noverlap,nfft,sr,flags)">nt_sgram</a>(z1,1024,32,[],1);
0202         title(<span class="string">'first'</span>);
0203         subplot 212;
0204         <span class="comment">%ERBspect(z2,sr);</span>
0205         <a href="nt_sgram.html" class="code" title="function [s,f,t]=nt_sgram(x,window,noverlap,nfft,sr,flags)">nt_sgram</a>(z2,1024,32,[],1);
0206         title(<span class="string">'last'</span>);
0207     <span class="keyword">end</span>
0208     <span class="keyword">if</span> nargout==0; clear IDX SCORE TODSS; <span class="keyword">end</span>
0209     
0210 <span class="keyword">end</span>
0211 
0212 <a name="_sub1" href="#_subfunctions" class="code">function y=norm2(x,n,ind)</a>
0213 [I,J]=ind2sub([n,n],ind);
0214 <span class="keyword">for</span> k=1:size(x,1)
0215     a=x(k,1:n);
0216     b=sqrt(a(I).*a(J));
0217     y(k,:)=x(k,:)./b;
0218 <span class="keyword">end</span>
0219 
0220     
0221     
0222</pre></div>
<hr><address>Generated on Mon 21-Mar-2016 10:28:43 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>